\documentclass{llncs}

\usepackage{color}
\usepackage{colortbl}
\usepackage{epsfig}
\usepackage{listings}
\usepackage{array}
\usepackage{longtable}
\usepackage{hhline}
\usepackage{cite}
\usepackage{boxedminipage}
\usepackage{graphicx}

\newcommand{\notesbox}[1]{
  \noindent\begin{center}\begin{boxedminipage}[h]{0.4\textwidth}{#1}\end{boxedminipage}\end{center}
}

\definecolor{lightgray}{gray}{.95}
\definecolor{darkgray}{gray}{.80}

\lstset{
  lineskip=0.5pt,
  basicstyle=\scriptsize,             % the size of the fonts that are used for the code
  %numbers=left,                      % where to put the line-numbers
  numberstyle=\scriptsize,            % the size of the fonts that are used for the line-numbers
  stepnumber=1,                       % the step between two line-numbers. If it is 1 each line will be numbered
  numbersep=3pt,                      % how far the line-numbers are from the code
  backgroundcolor=\color{lightgray},  % choose the background color. You must add \usepackage{color}
  showspaces=false,                   % show spaces adding particular underscores
  showstringspaces=false,             % underline spaces within strings
  showtabs=false,                     % show tabs within strings adding particular underscores
  frame=none,                         % adds a frame around the code
  tabsize=2,                          % sets default tabsize to 2 spaces
  captionpos=b,                       % sets the caption-position to bottom
  breaklines=true,                    % sets automatic line breaking
  breakatwhitespace=false,            % sets if automatic breaks should only happen at whitespace
  escapeinside={\%}{)}                % if you want to add a comment within your code
}

\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{ARC -- Automatic Repair of Concurrency Bugs}

\author{Kevin Jalbert, David Kelk, Jeremy S. Bradbury}

\institute{Software Quality Research Group\\
Faculty of Science (Computer Science)\\
University of Ontario Institute of Technology\\
Oshawa, Ontario, Canada\\
\email{\{kevin.jalbert, david.kelk, jeremy.bradbury\}@uoit.ca}}

\maketitle

\begin{abstract}

Automatic repair of single-threaded programs is being realized in practice.
Similar progress has not been made on the automatic repair of parallel
programs. We introduce a fully automated system for repairing
deadlocks and data races in parallel Java programs. The approach works on any
Java source code and requires only rudimentary test cases. Annotations, formal
specifications or other notations are not required. As only the concurrency
mechanisms are targeted the semantic meaning of the program is not changed.
An evolutionary strategy is used to mutate the existing program
until a variant is found that fixes the deadlocks and data races.
%As the first
%phase may introduce unneeded synchronization, a second phase attempts to
%optimize performance by removing the excess synchronization without sacrificing
%program correctness. We describe the approach and report on early results.

\end{abstract}

\section{Introduction}
\label{sec:introduction}

As computers and mobile devices now ship with more than one processor, programs
must take advantage of multiple processes as we have approached the end of
the\textit{free-lunch}~\cite{SL05}. Parallelism introduces a new class of bugs
and what makes them difficult to find is that they only occur in a small set of
execution interleavings~\cite{MQB07}. Even when a concurrency bug as been
detected, the repair of such a bug may not be apparent to the developer. It is
often the case that there are multiple threads and data accesses occurring at
the same time in different locations within the program.

We propose ARC (\textbf{A}utomatic \textbf{R}epair of \textbf{C}oncurrency
bugs): An automatic technique to repair deadlocks and data races in parallel
Java programs. Formal specifications, annotations and elaborate test suites are
not required. Only the Java source code and test(s) demonstrating the deadlocks
and/or data races are necessary. Evolutionary strategies (ES) are used to evolve
variants of the program until one is found that fixes the bugs in question.

The use of search-based software engineering (SBSE)~\cite{Har+10} techniques to
automatically repair bugs is not a novel idea~\cite{FNWG09, AY08, Arc08, WT10,
WNLF09, WFGN10}. Our proposed approach adapts the original idea of
automatically fixing \textit{sequential} programs to specifically target
\textit{concurrent} programs.

ARC uses ES to iteratively evolve a buggy program into a version that contains
the proper synchronization that resolves the concurrency bug. To evaluate
whether a program is fixed or now ARC takes advantage of the IBM's
ConTest~\cite{EFN+02} tool, which is used to explore different interleavings of
the program under test.

A common criticism in automatic bug repair techniques is large search space,
not to mention that parallelism introduces thread interleavings on top of this.
ARC innately lessens some of these problems due to a few design choices. First,
we limit the algorithm to only fixing deadlocks and data races. Second, ARC
only targets concurrency mechanisms (\texttt{synchronize} statements are added,
removed, and manipulated). Third, we use a specific set of fourteen
TXL~\cite{CHP91} operators based on the ConMAn suite~\cite{BCD06} to mutate the
concurrent program.  Finally, ARC only considers shared variables during the
mutation process. By considering these four design choices ARC operates on a
limited set of operators, and possible places where mutation can occur.

We cover background material related to concurrency and evolutionary strategies
in Sect.~\ref{sec:background}. The motivation for ARC along with an example
problem are presented in Sect.~\ref{sec:motivation}. In
Sect.~\ref{sec:approach} we describe the approach ARC uses to evolve a fix for
a concurrency bug using ES. We evaluate the fixing effectiveness of ARC in
Sect.~\ref{sec:experiments} by conducing an experiment using several programs.
Three challenges that ARC faces are identified in Sect.~\ref{sec:challenges}.
Threats to validity are covered in Sect.~\ref{sec:threats}. We describe the current
ongoing research to add a second phase to ARC that attempts to improve the
performance of the found fixes in Sect.~\ref{sec:ongoing}. In
Sect.~\ref{sec:related_works} we mention related works in the field of
automatic bug repair. Finally, future work and conclusions are covered in
Sect.~\ref{sec:future_work} \& Sect.~\ref{sec:conclusion}.

% In ongoing work we are adding a second phase to the system.  It attempts to
% improve performance by shrinking and removing synchronization blocks. As this
% can introduce data races or deadlocks, any mutant decreasing correctness is
% rejected. This second phase is still in development.  In the rest of the paper
% we concentrate on the first phase, bug fixing.

% To the best of our knowledge there has been no previous work using evolutionary
% strategies to fix bugs in concurrent software. There has been work involving
% the correction of concurrency bugs using self-healing~\cite{LVK08}. From the
% paper, \textit{The healing techniques based on influencing the scheduling do
% not guarantee that a detected problem will really be completely removed, but
% they can decrease the probability of its manifestation.} In contrast ARC is an
% off-line technique that fixes bugs by modifying the source code.

% The main contributions of this paper are:

% \begin{itemize}

% \item An algorithm to create fixes for deadlocks and data races in concurrent Java
% programs. Only the source code and tests demonstrating the bugs are necessary.
% To the best of our knowledge this is the first approach to fix both kinds of
% bugs in Java programs.

% \item Methods to constrain the search space: First, by specifically targeting
% synchronization mechanisms. Second, by using a limited number of TXL operators
% to transform the Java source.  Third, by targeting the variables used by multiple
% threads and ignoring the rest.

% \end{itemize}

\section{Background}
\label{sec:background}

\subsection{Concurrency Bugs}
\label{sec:concurrency}

In-proper synchronization in concurrent programs allows such conditions as data
races and deadlocks to occur. ARC attempts to fix these bugs by evolving a
program that contains proper synchronization.

%Concurrency is the act of having multiple threads executing in parallel.
%Concurrent programs are able to exploit multi-core systems where threads are
%distributed across each of the CPUs to increase performance. Concurrency
%introduces a new class of bugs, the \textit{heisenbugs}. Due to
%concurrent access to shared memory, threads are able to cause \textit{data
%races} and \textit{deadlocks}.

A \textbf{data race} has been defined as: \textit{``\ldots two or more
concurrent threads access a shared variable and when at least one access is a
write, and the threads use no explicit mechanism to prevent the access from
being simultaneous.''}~\cite{LSW07}.

A \textbf{deadlock} as: \textit{``\ldots a situation where two or more
processes are unable to proceed because each is waiting for one of the others
to do something in a deadlock cycle \ldots} For example, this occurs when a
thread holds a lock that another thread desires and vice-versa''~\cite{LSW07}.

These bugs are extremely difficult to detect due to the non-deterministic
nature of how threads are interleaved (the way the system schedules them).
Various techniques are available to detect concurrency bugs such as static
analysis~\cite{NA07,NPSG09,HP04}, stress testing~\cite{HSU03}, dynamic
analysis~\cite{JNPS09,EFN+02}, and model
checking~\cite{BHPV00,RDH03,OM03,MQB07,Holz97,JM04,HP00}.
% TODO Possibly trim out some of the techniques for bug detection?

\subsection{Evolutionary Strategies}
\label{sec:evolutionary_strategies}

ES is part of the family of heuristic search algorithms. The most commonly
referenced heuristic search technique is the genetic algorithm~\cite{GA92}. For
space reasons only the briefest outline of ES and it's place in the heuristic
search family is given.

A standard genetic algorithm is population based, uses mutation, crossover and
a fitness function to evolve solutions to problems. A proposed solution to the
problem is encoded as a member of the population. Each member is evaluated by a
fitness function. The more fit a member solution is, the greater the chance it
will pass it's genetic material (solution) on to the next generation.
\textit{Selection pressure preferentially selects better solutions.} Crossover
mixes these solutions to produce new ones while mutation injects fresh
information in to the population so it doesn't become stagnant.

ES is a simpler form of search than a genetic algorithm. A population of
proposed solutions is generated and mutated each generation. Crossover and
selection aren't used. Every members fitness is evaluated every generation. ES
end when a predetermined fitness is reached, after a set number of
generations have passed or after a search budget is exhausted.

%Why use mutation only? Sometimes it is unclear how to use crossover. For
%example, if the member solutions are Java programs, how does one ensure that
%when putting two halves of different programs together the resulting program is
%correct, makes sense or even compiles?

\section{Motivating Problem}
\label{sec:motivation}

\begin{quote}
\textit{Some properties are difficult or impossible to encode using test cases,
such as nondeterministic properties; GenProg cannot currently repair race
conditions, for example.}~\cite{GNFW11}
\end{quote}

%Concurrency bugs are difficult to detect and fix. Many tools exist that
%identify concurrent bugs.
In concurrent bugs, multiple code fragments can be involved, possibly in different units with
differently named variables. In this ambiguous scenario the appropriate fix is
not always clear. There has been work in concurrency anti-patterns that provide
a definition, problem, context and solution for concurrency
bugs~\cite{BJ09,FKLV12}.

In the left part of Fig.~\ref{fig:fixed_sample_datarace} the \texttt{read} and
\texttt{write} method access a shared variable. A very simple data race exists
because there is no atomic access to the \texttt{data} variable during the
reading or writing.
%Both methods are involved in the data race, and it is because of the interactions between these methods the data race is possible.
A solution involves synchronizing both accesses (Right part of
Fig.~\ref{fig:fixed_sample_datarace}). Synchronizing one method alone does not
fix the bug.

Phase 2 - the optimization phase in development - addresses the issue of unnecessarily
synchronizing the ``expensive loop'' and ``database query''.

%The solution in the right part of Fig.~\ref{fig:fixed_sample_datarace} is far
%from ideal. It forces other threads to wait unnecessarily while the write
%method works in the loop and database sections. An optimization is to shrink
%the critical region (the synchronized statements) to only guard access to the
%shared variable (as shown in Fig.~\ref{fig:optimized_sample_datarace}).

\begin{figure}[h]
\begin{minipage}{5cm}
\footnotesize{\textbf{Buggy Program:}}
\begin{lstlisting}[language=Java, morekeywords={synchronize}]
write(int var1){
  ... // Expensive loop
  data = var1;
  ... // Database query
}

int public read(){
  return data;
}
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{5cm}
\footnotesize{\textbf{Fixed Program:}}
\begin{lstlisting}[language=Java, morekeywords={synchronize}]
synchronize write(int var1){
  ... // Expensive loop
  data = var1;
  ... // Database query
}

int synchronize read(){
  return data;
}
\end{lstlisting}
\end{minipage}
\caption{A developer first synchronizes the \texttt{read} function, yet the bug
still exists. Synchronizing the \texttt{write} method as well fixes it.}
\label{fig:fixed_sample_datarace}
\end{figure}

%\begin{figure}[t]
%\begin{minipage}{5cm}
%\footnotesize{\textbf{$1^{st}$ Optimization on Fix:}}
%\begin{lstlisting}[language=Java, morekeywords={synchronize}]
%public write(int var1){
%  ... // Expensive loop
%  synchronized(this){
%    data = var1;
%    ... // Database query
%  }
%}
%
%int synchronize read(){
%  return data;
%}
%\end{lstlisting}
%\end{minipage}\hfill
%\begin{minipage}{5cm}
%\footnotesize{\textbf{$2^{nd}$ Optimization on Fix:}}
%\begin{lstlisting}[language=Java, morekeywords={synchronize}]
%public write(int var1){
%  ... // Expensive loop
%  synchronized(this){
%    data = var1;
%  }
%  ... // Database query
%}
%
%int synchronize read(){
%  return data;
%}
%\end{lstlisting}
%\end{minipage}
%\caption{A developer shrinks the critical region to exclude the expensive loop.
%They shrink the critical region again to exclude the database query as a
%further optimization.}
%\label{fig:optimized_sample_datarace}
%\end{figure}

From a developer's standpoint there is a lot of work involved in creating a fix
for parallel bugs as multiple, unrelated changes are not uncommon.
%Two changes were required to functionally fix the example program.
%Two additional changes were required to improve the non-functional performance.
Automated tools in software testing and debugging are needed as they have the
potential to reduce the vast amount of resources spent on software testing
(upwards to \$59.5 billion)~\cite{RTI02}.
%ARC provides an automated approach to fixing the \textit{functionality}
%, and then optimizing the \textit{non-functional} performance
%of programs with deadlocks and data races.

\section{ARC's Approach}
\label{sec:approach}

%ARC aims to automatically repair concurrency bugs like the one presented in
%Sect.~\ref{sec:motivation}.
A high-level overview of ARC's approach is
presented in Fig.~\ref{fig:process}. There are two inputs to ARC: A buggy
concurrent Java program and a JUnit test suite. The test suite is necessary as
it acts like an oracle to determine if the bug still exists in the program. One
limitation of ARC (and of other automatic bug fixing techniques mentioned in
Sect.~\ref{sec:related_works}) is that it can only fix bugs detectable by the
test suite.

\begin{figure}[h]
  \centering
  \includegraphics[width=7.0cm]{figures/process.pdf}
  \caption{High Level Overview of ARC's Repair and Optimization Process}
  \label{fig:process}
\end{figure}

%ARC's complete approach is accomplished in two phases, the \textit{Functional
%Phase} and the \textit{Non-Functional Phase}. Both are similar in terms of the
%steps they follow, with slight variations to accomplish different goals. The
%first phase attempts to fix the buggy program while the second attempts to
%optimize its performance.

The next sections detail the fixing process as shown in Fig.~\ref{fig:phases_internals}.
The key aspect of ARC's approach fall in the mutation and evaluation steps.

\begin{figure}[h]
  \centering
  \includegraphics[width=4.50cm]{figures/phases.pdf}
  \caption{Internal View of ARC's Phases}
  \label{fig:phases_internals}
\end{figure}

\subsection{Initialize Population}
\label{sec:initialize_population}

ARC begins by initializing the population of individuals. This
involves copying the program for each individual of the ES.  Each program
is then mutated independently during the fixing process.
%For the non-functional phase ARC has already produced the fixed
%program so each individual receives a copy of the fixed program to optimize.

\subsection{Generate Mutants and Update Individual's Representation}
\label{sec:update_individual_representation}

For each individual the previous generation's Java code (original program in generation 1)
 is used to generate all
possible mutations for each individual that can be applied for this generation.
%This step generates all possible mutants for each individual, though the actual mutation is applied
%in the next step.
%Internally ARC keeps track of the mutants using a
%representational form as shown in Table~\ref{tbl:individual_representation}. As
%there exists multiple types of mutations, individuals are represented using a
%2-dimensional array of the mutation operators and the number of mutation
%instances generated.

%\begin{table}[h]
%\begin{center}
%\caption{An example representation of an individual, each 0 represents an
%instance of that mutation type that has been generated. It is possible for up
%to $n$ mutation operators with no-limit to the number of instances per
%operator.}
%\begin{tabular}{|l|l|}
%\hline
%\textbf{Operator} & \textbf{Instances}\\
%\hline
%Mutation 1 & 0\\
%\hline
%Mutation 2 & 0 0 0\\
%\hline
%Mutation 3 & --\\
%\hline
%\ldots & \ldots\\
%\hline
%Mutation $n$ & 0 0\\
%\hline
%\end{tabular}
%\label{tbl:individual_representation}
%\end{center}
%\end{table}

The set of mutation operators ARC uses are listed in Table~\ref{tbl:operators}
%each operator can aid in repairing and/or optimizing the program.
Most have been derived from the ConMAn
operators~\cite{BCD06}. These operators work by searching for a pattern within
the source code and then transforming it according to a set of rules. An
example of the EXSB mutation operator is shown in Fig.~\ref{fig:EXSB_example}.

% Original table with functional and non-functional
%\begin{table}[h]
%\caption{Set of mutation operators used by ARC. Each mutation operator is
%active during the indicated phases.}
%\begin{center}
%\begin{tabular}{|l|l|c|c|}
%\hline
%\textbf{Operator} & \textbf{Acronym} & \textbf{Functional} & \textbf{Non-Functional}\\
%\hline
%Add synch. around synch. & ASAS & $\surd$ &\\
%\hline
%Add synch. around variable & ASAV & $\surd$ &\\
%\hline
%Add synch. in method header & ASIM & $\surd$ &\\
%\hline
%Add synch. around method & ASM & $\surd$ &\\
%\hline
%Change synch. order & CSO & $\surd$ &\\
%\hline
%Expand synch. before & EXSB & $\surd$ &\\
%\hline
%Expand synch. after & EXSA & $\surd$ &\\
%\hline
%Remove synch. around synch. & RSAS & $\surd$ & $\surd$\\
%\hline
%Remove synch. around variable & RSAV & $\surd$ & $\surd$\\
%\hline
%Remove synch. in method header & RSIM & $\surd$ & $\surd$\\
%\hline
%Remove synch. around method & RSM & $\surd$ & $\surd$\\
%\hline
%Shrink synch. before & SHSB & & $\surd$\\
%\hline
%Shrink synch. after & SHSA & & $\surd$\\
%\hline
%\end{tabular}
%\label{tbl:operators}
%\end{center}
%\end{table}

% Modified table of functional only operators
\begin{table}[h]
\caption{Set of mutation operators used by ARC.}
\begin{center}
\begin{tabular}{|l|l|c|c|}
\hline
\textbf{Operator} & \textbf{Acronym} \\
\hline
Add synch. around synch. & ASAS \\
\hline
Add synch. around variable & ASAV \\
\hline
Add synch. in method header & ASIM \\
\hline
Add synch. around method & ASM  \\
\hline
Change synch. order & CSO  \\
\hline
Expand synch. before & EXSB  \\
\hline
Expand synch. after & EXSA  \\
\hline
Remove synch. around synch. & RSAS  \\
\hline
Remove synch. around variable & RSAV  \\
\hline
Remove synch. in method header & RSIM  \\
\hline
Remove synch. around method & RSM  \\
\hline
\end{tabular}
\label{tbl:operators}
\end{center}
\end{table}

\begin{figure}[h]
\vspace{2mm}
\begin{minipage}{5cm}

\footnotesize{\textbf{ Program $P$:}}
\begin{lstlisting}[language=Java, morekeywords={synchronize}]
  ...
  obj.write(var1);
  synchronized(lock){
    myHash.remove(var1);
  }
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{5cm}
\footnotesize{\textbf{ Program $P'$:}}
\begin{lstlisting}[language=Java, morekeywords={synchronize}]
  ...
  synchronized(lock){
    obj.write(var1);
    myHash.remove(var1);
  }
\end{lstlisting}
\end{minipage}

\caption{An example of the EXSB (expand synchronization before) mutation
operator.}
\label{fig:EXSB_example}
\end{figure}

As ARC mutates synchronization aspects of programs, the mutations themselves
can alter the appearance of future mutations. This causing the search space of
possible mutations to potentially changes in every generation.
%Thus ARC must
%update the representation according to the latest state of the program's source
%code each generation.

\subsection{Apply a Mutation to an Individual}
\label{sec:mutate_individuals}

Once all mutations are generated for each individual ARC selects a type of
mutation (e.g. EXSB) and then an instance of
it (e.g. 4th mutant generated) from those available. The
selected mutation of the previous generation's code is applied and becomes the current
generation's code. ARC at this point will re-compile the project to ensure that
the mutation consists of valid syntax. In the situation that the compilation
fails another mutation type and instance is selected until a valid combination is
found.

ARC can leverage historical information about previous evaluations with the
mutation operators along with information about the current dominating bug type
found during testing. These two pieces of data add weight to operators
that have been successful in the past, as well as to select operators that
appear to reduce the occurrences of either deadlocks or data races more often.
This heuristic is further detailed in
Sect.~\ref{sec:recalculate_operator_weighting}. Currently, operators are weighted.
The mutants they generate are not.  Mutants are selected randomly with equal
probability.

\subsection{Evaluate Individuals}
\label{sec:evalute_individuals}

A mutation may be beneficial, destructive or benign. We must evaluate it to
determine the effect on the program. A key problem is the unpredictability of
thread interleavings. If a concurrency bug appears only rarely, how can we gain
confidence that a proposed fix actually works? ARC uses IBM's ConTest
tool~\cite{EFN+02} to instrument the project by injecting noise into the
program. The injected noise causes threads to yield, sleep and wait randomly,
effectively causing an execution of the program to explore a diverse set of
scheduled interleavings. By running the instrumented version of the
program multiple times we gain more confidence that a larger set of the
interleavings are explored. Running the instrumented program multiple times is
the most time consuming aspect of ARC.

%In the first phase ARC attempts to repair the buggy program, thus the
Fitness is determined by the number of successful ConTest executions.
%More successes translates in to higher fitness value.
We consider timeouts as a positive
factor in the fitness function as it could either result in a deadlock or a
successful execution given more time. We do weight timeouts less than a
successful execution as it could still result in a deadlock.
Figure~\ref{fig:functional_fitness} displays the fitness function.

\begin{figure}[h]
\begin{footnotesize}
\begin{center}
$functional\ fitness(P) = (s \times sw) + (t \times tw)$
\end{center}
\end{footnotesize}
\begin{scriptsize}
\begin{center}
$s = \#\ of\ successful\ executions$ \\
$sw = success\ weighting$ \\
$t = \#\ of\ timeout\ executions$ \\
$tw = timeout\ weighting$
\end{center}
\end{scriptsize}
\caption{Fitness Function for Functional Phase}
\label{fig:functional_fitness}
\end{figure}

If ARC finds an individual that achieves 100\% successful executions,
we need to ensure it is truly a fix. It is possible that a
proposed solution could still contain a concurrency bug that escaped detection
because the bug exhibiting interleavings was not encountered. Our safeguard is
to run ConTest an additional number of times (some multiple of the previous
number of runs). If the fix still holds even after this validation we feel
confident the solution is indeed a true solution. If any of the additional
executions fail, the proposed fix is rejected and the evolutionary process
continues.



\subsection{Check Terminating Condition}
\label{sec:check_terminating_condition}

ARC continues to evolve and evaluate individuals until
%some terminating condition is met. The following conditions are for the functional phase:
a solution is found (100\% successful executions in validation) or or the generational limit /
evaluations budget is exceeded.
%The following conditions are for the non-
%functional phase: The population has converged (no improvement has been seen in
%$x$ generations), no more mutations are generated, or the generational limit is
%hit.

\subsection{Replace Weakest Individuals}
\label{sec:replace_weakest_individuals}

With any evolutionary algorithm it is entirely possible for an individual to
stray down a path leading to little or no improvement. To encourage individuals
to explore more fruitful areas of the state space we employ a replacement
strategy that replaces the lower $w$ percentage of individuals with a random
individual from the upper $x$ percent or the original buggy program with y percent chance.
These replacements only occur after an
individual has underperformed for $y$ generations. We believe the
\textit{competent programmer hypothesis} applies so the corrected
program isn't very far away in the state space from the original buggy program.
%Therefore we provide a chance for an under-performing individual to reset
%back the initial state to allow the individual to explore from the starting
%point again.

\subsection{Recalculate All Operator's Weighting}
\label{sec:recalculate_operator_weighting}

ARC utilizes a heuristic approach to select the mutation operator in the
mutation step. A sliding window of $n$ generations is used to determine the
success of previously used mutation operators. Operators that improve fitness
are weighted more heavily and are more likely to be selected. A sliding window
is used to prevent dominance of operators and to allow for flexibility in
changing weighting based on recent history. The weighting is designed to ensure
the chance of selecting an operator is always greater than zero regardless of
performance.
%To ensure this approach is up to date the current weighting for
%each operator is recalculated based on the new feedback received from the
%population. In the functional phase we consider a separate weighting for data
%races and deadlocks to remain accurate in the use of this heuristic.

\section{Experiments}
\label{sec:experiments}

%Due to the ARCs heuristic nature it is entirely possible for a program to
%perform better or worse then it did originally. We are interested in both ARCs
%ability to find fixes and ARCs effect on performance of solutions found.

ARC is not a quick process. Executing ConTest (population $\times$ generations
$\times$ \# runs $\times$ ConTest run time) many times alone can take significant
resources. Execution times on programs in the experimental section have ranged between
roughly 5 minutes and 4 hours.

\subsection{Experimental Setup}
\label{sec:experimental_setup}

ARC is evaluated against selected programs from the IBM Concurrency
Benchmark~\cite{EHSU06}. This set of programs is rather small yet demonstrate a
variety of concurrent bug types. Unfortunately, none of the programs contain
JUnit test suite that ARC requires. We manually created JUnit test suites
without altering the programs and their bugs's behaviour\footnote{One incorrect
program was fixed so that it properly exhibited its concurrency bug.}. Details
on the programs are presented in Table~\ref{tbl:used_programs}.
% TODO Is the footnote still true? (CC: David)

% TODO Maybe just remove the Bug Pattern (as it would need more explanation)

\begin{table}[h]
\caption{The set of programs used to evaluate ARC. The test suite for each
program is excluded from these values.}
\begin{center}
\begin{tabular}{|l|r|r|l|l|}
\hline
\textbf{Program} & \textbf{SLOC} & \textbf{Classes} & \textbf{Bug Type} & \textbf{Bug Pattern}\\
\hline
account & 165 & 3 & Data Race & NoLock\\
\hline
accounts & 75 & 2 & Data Race & NonAtomicAssumedAtomic\\
\hline
airline & 93 & 1 & Data Race & Interference\\
\hline
allocation & 165 & 3 & Data Race & TwoStageAccess\\
\hline
bubble & 246 & 4 & Data Race & NonAtomicAssumedAtomic,\newline OrphanedThread\\
\hline
bubblesort2 & 104 & 2 & Data Race & Initialization-Sleep\\
\hline
buffer & 319 & 5 & Data Race & NotifiyInsteadOfNotifyAll\\
\hline
bufwriter & 170 & 5 & Deadlock & NoLock\\
\hline
deadlock & 109 & 2 & Deadlock & Deadlock\\
\hline
lottery & 157 & 2 & Data Race & NonAtomicAssumedAtomic,\newline NoLock, BlockingCriticalSection\\
\hline
mergesort & 281 & 2 & Data Race & NonAtomicAssumedAtomic\\
\hline
pingpong & 143 & 4 & Data Race & Null-Pointer Exception\\
\hline
\end{tabular}
\label{tbl:used_programs}
\end{center}
\end{table}

ARC was designed to be flexible in terms of the parameters that can be
configured. Table~\ref{tbl:used_parameters} lists and describes each parameter,
including the values selected for evaluation. Values were selected based on our
experience with ARC.

% TODO Maybe reduce this to the common ES parameters?

\begin{table}%[h]
\caption{The set of parameters that ARC uses along with their descriptions and
used values for the experimentations.}
\begin{center}
\lstset{basicstyle=\scriptsize}
\begin{tabular}{|l|l|r|}
\hline
\textbf{Parameter} & \textbf{Description} & \textbf{Value}\\
\hline
Project Test MB & The amount of memory allocated for the testing & 2000\\
\hline
ConTest Runs & Test suite executions per gen. per member & 10\\
\hline
Validation Mult. & Multiplier on ConTest runs when validating the functionality & 15\\
\hline
Timeout Mult. & Time multiplier for ConTest before timeout & 15\\
\hline
Evolut. Gen. & Maximum number of generations in fixing phase & 30\\
\hline
Evolution Population & Population size for the evolutionary strategy & 30\\
\hline
Replace Lowest \% & Lowest $n$\% of population replaced & 10\\
\hline
Replace With Best \% & Replace underperfomer with best individual $n$\% of the time & 75\\
\hline
Replace min turns & Minimum time underperforming & 3\\
\hline
Replace Interval & Every $n$ generations, underperformers are replaced & 5\\
\hline
Ranking Window & Size of sliding window for operator weighting & 5\\
\hline
Success Weight & The weighting applied for successful executions & 100\\
\hline
Timeout Weight & The weighting applied for timeout executions & 50\\
\hline
Improv. Window & Size of window for convergence check & 10\\
\hline
Avg. Fit. Delta & Minimum average fitness improvement required & 0.01\\
\hline
Best Fit. Delta & Minimum best fitness improvement required & 1\\
\hline
\end{tabular}
\label{tbl:used_parameters}
\end{center}
\end{table}

\subsection{Experimental Results}
\label{sec:experimental_results}

Each program was run through ARC a total of 5 times using the parameters
described in Table~\ref{tbl:used_parameters}. The results of each program is
summarized in Table~\ref{tbl:summary_results}.

\begin{table}%[h]
\caption{Summary of the results of running the programs
(Table~\ref{tbl:used_programs}) through ARC 5 times.}
\begin{center}
\lstset{basicstyle=\scriptsize}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Program} & \textbf{Gen. Fix Found} & \textbf{Time Taken (h:m:s)}\\
\hline
account & 4, 15, 4, 1, 1 & 0:19:53, 1:08:30, 0:19:54, 0:06:39, 0:06:29\\
\hline
accounts & 1, 1, 1, 1, 1 & 2:02:57, 2:08:11, 2:05:31, 2:10:18, 2:36:24\\
\hline
airline & --, --, --, --, -- & 3:58:07, 3:56:19, 3:49:34, 3:53:14, 3:57:51\\
\hline
allocation & 1, 3, 2, 3, 2 & 0:12, 1:12, 1:12, 1:12, 1:12\\
\hline
bubble & 1, 3, 2, 3, 2 & 0:12, 1:12, 1:12, 1:12, 1:12\\
\hline
bubblesort2 & 1, 3, 2, 3, 2 & 0:12, 1:12, 1:12, 1:12, 1:12\\
\hline
buffer & --, --, --, --, -- & 4:43:50, 4:45:12, 5:07:03, 4:58:27, 5:02:30\\
\hline
bufwriter & 1, 3, 2, 3, 2 & 0:12, 1:12, 1:12, 1:12, 1:12\\
\hline
deadlock & 1, 1, 1, 1, 1 & 0:06:45, 0:05:43, 0:06:45, 0:05:40, 0:07:51\\
\hline
lottery & 1, 3, 2, 3, 2 & 0:12, 1:12, 1:12, 1:12, 1:12\\
\hline
mergesort & 1, 3, 2, 3, 2 & 0:12, 1:12, 1:12, 1:12, 1:12\\
\hline
pingpong & 1, 1, 1, 1, 1 & 0:39:57, 0:12:47, 0:46:21, 0:46:16, 0:42:02\\
\hline
\end{tabular}
\label{tbl:summary_results}
\end{center}
\end{table}


\section{Challenges}
\label{sec:challenges}

ARC has three major challenges to face:

\textbf{Large Solution Space}: Controlling the search space is critical to ARC's
success.  We are only considering
deadlocks and data races and are only mutating concurrency mechanisms with concurrency
mutation operators. This significantly shrinks the search space to explore
to find a fix. Operator weighting and only using variables involved in concurrency
further constrain the space.
%In Arcuri's approach~\cite{AY08}, they were
%considering the whole program along with a large set of mutations. When
%combined with a large number of places to apply them it creates an extremely
%large search space for finding the solution.

The search space can be reduced even further by considering only the mutations
falling on the error path (Used in Weimer's approach~\cite{GNFW11}) or even by
using external detection tools for potential a locational where the bug might
be residing.
%These two suggestions are considered for future work to minimize
%the solution space.

\textbf{Dependence on Test Suite}: ARC depends on a minimal test suite for the
program being repaired. In both Arcuri's and Weimer's
approach~\cite{AY08,GNFW11} the test suites are used to both guard the
program's functionality and to indicate a bug is present. ARC requires a test
suit to exhibit the bug. ARC currently has no solution for dealing with bugs
that occur outside of the test suite's coverage.
%Arcuri's and Weimer's
%approaches also has no solution for this.

%There has been some work that attempts to co-evolve the test suite at the same
%time to help check for new situations~\cite{WT10}. We assume the
%test suite is comprehensive enough to detect all bugs. ARC will eventually only
%consider using mutation operators that fall within the coverage of the test
%suite to avoid introducing new bugs the test suite cannot detect.

\textbf{Program Readability}: Automatically fixing a program
raises the question of source readability. This is a concern as developers want to
understand the fix as well. All TXL operators were constructed to follow Java's
coding conventions and pretty-print all code on output.

%Posnett et. al.~\cite{PHD11} use the following
%metrics to estimate readability:

%\begin{itemize}
 % \item Moving lines around does not affect the program's readability
 % \item The addition of existing tokens does not reduce the program's
%readability as much as adding new unique statements
%\end{itemize}

%ARC simply adds, removes manipulates synchronization statements.
%In most cases
%there will already tokens regarding synchronization within the program. Thus,
%the addition of new synchronization does not reduce the program's readability
%that much. For the mutations that manipulate the synchronization statements ARC
%is effectively moving lines around, which does not reduce the program's
%readability.

% Readability metrics for programs fixed by ARC are collected in
% Table~\ref{tbl:readability}.
% \ldots % TODO

% \begin{table}[h]
% \caption{The program readability values from the buggy program to the fixed
% program to the optimized program.}
% \begin{center}
% \begin{tabular}{|l|p{2cm}|p{2cm}|p{2cm}|p{2cm}|p{2cm}|}
% \hline
% \textbf{Program} & \textbf{Buggy Program's Readability} & \textbf{Fixed Program's Readability} & \textbf{Optimized Program's Readability} & \textbf{Change from Buggy to Fixed} & \textbf{Change from Fixed to Optimized}\\
% \hline
% account & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% accounts & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% airline & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% allocation & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% bubble & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% bubblesort2 & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% buffer & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% bufwriter & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% deadlock & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% lottery & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% mergesort & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% pingpong & 100 & 110 & 105 & +10\% & -4.6\%\\
% \hline
% \end{tabular}
% \label{tbl:readability}
% \end{center}
% \end{table}

\section{Threats to Validity}
\label{sec:threats}

% TODO


\section{Ongoing Research}
\label{sec:ongoing}

ARC may introduce unnecessary concurrency during the fixing process.
We are experimenting with and implementing a second phase where the
same kind of evolutionary strategy attempts to optimize the program by
shrinking and removing concurrency blocks.  Challenges include
dealing with re-introducing bugs and finding metrics to determine when
one proposed optimization performs better than another.  Execution time is
one.  We are investigating others as well.

%\begin{figure}[h]
%\begin{footnotesize}
%\begin{center}
%$non-functional\ fitness(P) = \frac{worst\ score}{[sig_t \times unc(t)] + [sig_c \times unc(c)]}$
%\end{center}
%\vspace{0.1cm} \textit{Where:} \vspace{0.1cm}
%\end{footnotesize}
%\begin{scriptsize}
%\begin{center}
%$unc(x) = \frac{(x_{max} - x_{min})}{x_{avg}}$ \\ \vspace{0.2cm}
%$
%  sig_t = \left\{
%  \begin{array}{l l}
%    t/c & \quad if\ t\ > c \\
%    c/t & \quad if\ c\ > t \\
%  \end{array} \right.
%$ \\ \vspace{0.2cm}
%$
%  sig_s = \left\{
%  \begin{array}{l l}
%    c/t & \quad if\ t\ > c \\
%    t/c & \quad if\ c\ > t \\
%  \end{array} \right.
%$ \\
%\end{center}
%\end{scriptsize}
%\caption{Fitness Function for Non-Functional Phase}
%\label{fig:nonfunctional_fitness}
%\end{figure}

\section{Related Works}
\label{sec:related_works}

There are a number of approaches to automatically hide or fix bugs in programs.
Co-evolutionary competition between programs with bugs and test cases is used
in~\cite{AY08, Arc08, WT10}. Both approaches require formal specifications and
both use genetic programming to evolve fixes.
%Co-evolution is used to cause competition between the evolving fixes and test cases.
%In both cases the
%resulting framework is tested only against a toy sorting algorithm with mixed
%success. The untargeted nature of the fixing process is the largest limitation.
%No effort is made to constrain the search space of the problem.

Significant advances are made in~\cite{FNWG09, WNLF09, NWLF09, WFGN10,
GNFW11}. Formal specifications are not required. Instead, test cases are
used to demonstrate the bug and describe the desired functionality that must be
preserved. To address the limitations of the previous approach they introduce
two innovations: First, they assume the bug is written correctly in another
part of the program. Second, they determine the error path on which the bug
occurs and target those statements specifically for repair. Together these
additions constrain the state space enough that the framework can fix real bugs
in real programs.

Similar to the work done here,~\cite{KLT+07, LVK08} uses ConTest to heal data
races. From their paper, \textit{``Healing concurrency problems is about
limiting or changing the probability of interleaving, such that bugs will be
seen less.''}
%In contrast, our approach uses ConTest in a framework that fixes
%both deadlocks and data races.

A framework is created in~\cite{CB05} to ``repair'' buffer overflow attacks.
When one is identified, the program state is reset to what it was before the
attack. The attack packet is discarded then the program continues running.
%As in the previous approach the goal is to hide the problem, not fix it.

SAT solving is used in~\cite{AY07}  to repair shared memory concurrent programs
``w.r.t. CTL specifications'' where processes atomically read, write one shared
variable at a time. All that is required is the concurrent program and a
specification in modal or temporal logic.
%It is unclear if the fix is applied to the program or the specification of the program.


\section{Future Work}
\label{sec:future_work}

Targeting the variables, functions and classes on the error path is another
feature we would like to add. It has shown great success in helping to isolate
and automatically fix bugs in single-threaded programs~\cite{FNWG09, NWLF09,
WFGN10, GNFW11}. We believe it will do the same for multi-threaded programs.

We also plan to experiment with new operators. Potential additions include
splitting or merging synchronization blocks and adding new locks. Through
experimentation we plan to optimize the existing set of mutation operators to
maximize their capabilities.  An intriguing possibility is adding crossover to
the algorithm, changing it into a genetic algorithm.

Many new concurrency structures were introduced in Java 5. Expanding ARC's
operators to deal with new anti-patterns~\cite{BJ09, FKLV12, BCD06} gives ARC
the ability to fix additional types of bugs.

We plan to optimize ARC's approach to reduce the time taken for finding a fix.
One idea is to short-circuit the identification of a correct individual, as
currently ARC only identifies a solution after evaluating all individuals of
the current generation.

\section{Conclusion}
\label{sec:conclusion}

Little work has been done on automatically fixing parallel programs. We
introduced ARC -- a framework that automatically fixes deadlocks and data races
in parallel Java programs.
%It uses an evolutionary algorithm operating in two
%phases. Bugs are fixed in the first phase, then concurrency is optimized in the
%second.

Experiments were conducted to evaluate ARC using a set of 12 programs found in
a concurrency benchmark. The results indicate that ARC is \ldots % TODO

\bibliographystyle{splncs03}
\bibliography{SSBSE2012}

\end{document}
