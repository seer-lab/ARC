\section{Conclusions and Future Work}
\label{sec:conclusion}


We have successfully demonstrated using an evolutionary strategy to automatically repair concurrent Java programs. Our approach overcomes several of the existing challenges of program repair including: (1) concurrent programs can have many possible thread interleavings which can make bugs harder to detect and (2) concurrent programs have to contend with complex interaction bugs that not possible in single-threaded source code. Our approach is implemented in the tool ARC which is capable of repairing data races and deadlocks in concurrent Java programs.

 Experiments were conducted to evaluate ARC using a set of 8 programs drawn from the IBM concurrency benchmark. ARC was able to fix the data races and deadlocks in all 6 of the fixable programs and find optimal fixes
for 5 of them. We plan to make ARC and the data from our experiment publicly available to increase the reproducibility of our results.

Although ARC was successful with the set of small programs from the IBM concurrency benchmark we still need to evaluate ARC's scalability with respect to large open source projects. In addition to scalability, ARC faces a number of other challenges moving forward:  performance of the repaired programs, efficient use of noise making tools like ConTest, performance of ARC and expanding the set of mutation operators to detect a wider variety of concurrency bug. The next step in our research is to complete the second phase of ARC (described in Sect.~\ref{sec:ongoing}) that attempts to 
optimize the performance of the fixed programs. To address the efficient use of ConTest we plan to explore different heuristics for seeding noise and different optimizations in terms of ConTest's configuration~\cite{KLVU10}.

In addition to improving the efficiency of ConTest we also plan to improve other aspects of ARC. Fro example, targeting the variables, functions and classes on the error path is an important feature  we would like to add. It has shown great success in helping to isolate and automatically fix bugs in single-threaded programs~\cite{FNWG09, WNLF09, NWLF09, WFGN10, GNFW11, LDFW12}. It should be straight forward to integrate a static analysis tool~\cite{HP04, NPSG09, NWLF09} like Chord.  We seed the first generation with mutants from the target area and grow the search from there.

%As stated above, ARC isn't quick.  We plan to optimize issues around speed: Immediate evaluation of potential fixes -- instead of at the end of a generation, memory caching and mutation creation on demand, instead of exhaustively. ConTest is the largest drain on resources in terms of ARC. There has been some work on exploring optimizations in terms of the configuration of ConTest, which we can take advantage of as we currently use the default configuration~\cite{KLVU10}.

%
Finally, we plan to experiment with new mutation operators. Potential additions include splitting
or merging synchronization blocks and adding new locks. Through experimentation
we plan to optimize the existing set of mutation operators to maximize their
capabilities.  %Many new concurrency structures were introduced in Java 5.
Furthermore, we would like to expand ARC's operators to deal with new anti-patterns~\cite{BJ09, FKLV12,
BCD06} and give ARC the ability to fix additional types of bugs. %An intriguing possibility is adding crossover, changing ARC into a genetic or gene expression algorithm.
