 \section{Introduction}
\label{sec:introduction}

As computers and even mobile devices now ship with more than one core per chip, programs must parallelize~\cite{SL05} to take advantage of improvements in processing power. Improvements in clock speed alone won't save us anymore. Parallelism introduces a new class of bugs that are difficult to find because they may only occur in a small set of thread interleavings~\cite{MQB07}. Even when a concurrency bug has been detected, its repair is often non-trivial. Many concurrency bugs are the result of the interaction of different code fragments executing in different threads within a program. For example, in a data race multiple threads write to shared data at the same time.

To address the challenges of detecting and fixing concurrent programs we propose ARC (\textbf{A}utomatic \textbf{R}epair of \textbf{C}oncurrency bugs) -- an automatic technique to repair deadlocks and data races in concurrent Java programs. ARC requires no formal specifications or annotations. Only the Java source code and tests capable of demonstrating the existing deadlocks and data races are necessary. ARC works by using a genetic algorithm without crossover (GA\negC) to evolve variants of a ``buggy'' concurrent Java program until one is found that fixes the bugs in question.

The use of search-based software engineering (SBSE)~\cite{Har+10} techniques to automatically repair bugs is not a novel idea~\cite{FNWG09, WNLF09, NWLF09, WFGN10, GNFW11, LDFW12}. Our proposed approach adapts the original idea of automatically fixing \textit{sequential} programs to specifically target \textit{concurrent} programs. Several challenges exist in concurrent program repair  that are not relevant in sequential source code: (1) concurrent programs can have many possible thread interleavings which can make bugs harder to detect and (2) concurrent programs have to contend with complex interaction bugs that not possible in single-threaded source code. In a recent paper, Le Goues et al., who developed one of the first approaches to search-based code repair, acknowledged the challenge of fixing concurrent programs -- \textit{``Some properties are difficult or impossible to encode using test cases, such as nondeterministic properties; GenProg cannot currently repair race conditions, for example.''}~\cite{GNFW11}.

A common problem for automatic bug repair techniques is the large search space of possible fixes. Applying these techniques to  concurrent programs adds thread interleavings to the search space. ARC incorporates techniques to constrain the search space and make it tractable. First, we limit the algorithm to only fixing deadlocks and data races in concurrent Java programs. Second, ARC only targets concurrency mechanisms. \texttt{Synchronize} statements are added, removed, and manipulated. Third, we use a specific set of 11 TXL~\cite{CHP91} operators based on the ConMAn suite~\cite{BCD06} to mutate the program.  Fourth, a static analysis of the program is performed to find and target the shared classes, methods and variables. Fifth, the ConTest noising tool is used to explore the interleaving space and refine the list of shared variables.  Note that the framework is general enough to fix additional kinds of concurrency bugs and work on other programming languages. This evaluation is limited to fixing deadlocks and data races in Java programs.

In the next section (Sect.~\ref{sec:background}) we cover the background material related to concurrency and genetic algorithms. The motivation for ARC along with an example problem is presented in Sect.~\ref{sec:motivation}. In Sect.~\ref{sec:approach} describes ARCs approach to evolving fixes for data races and deadlocks using GA\negC. We evaluate the effectiveness of ARC in Sect.~\ref{sec:experiments} on a series of programs from the IBM benchmark. Threats to validity are discussed in Sect.~\ref{sec:threats}. . In Sect.~\ref{sec:related_works} we discuss related works in the field of automatic program repair and finally we present conclusions and future work in Sect.~\ref{sec:conclusion}.

% In ongoing work we are adding a second phase to the system.  It attempts to
% improve performance by shrinking and removing synchronization blocks. As this
% can introduce data races or deadlocks, any mutant decreasing correctness is
% rejected. This second phase is still in development.  In the rest of the paper
% we concentrate on the first phase, bug fixing.

% To the best of our knowledge there has been no previous work using evolutionary
% strategies to fix bugs in concurrent software. There has been work involving
% the correction of concurrency bugs using self-healing~\cite{LVK08}. From the
% paper, \textit{The healing techniques based on influencing the scheduling do
% not guarantee that a detected problem will really be completely removed, but
% they can decrease the probability of its manifestation.} In contrast ARC is an
% off-line technique that fixes bugs by modifying the source code.

% The main contributions of this paper are:

% \begin{itemize}

% \item An algorithm to create fixes for deadlocks and data races in concurrent Java
% programs. Only the source code and tests demonstrating the bugs are necessary.
% To the best of our knowledge this is the first approach to fix both kinds of
% bugs in Java programs.

% \item Methods to constrain the search space: First, by specifically targeting
% synchronization mechanisms. Second, by using a limited number of TXL operators
% to transform the Java source.  Third, by targeting the variables used by multiple
% threads and ignoring the rest.

% \end{itemize}
